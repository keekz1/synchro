datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum UserRole {
  SOFTWARE_ENGINEER
  BACKEND_DEVELOPER
  FRONTEND_DEVELOPER
  FULL_STACK_DEVELOPER
  MOBILE_DEVELOPER
  DEVOPS_ENGINEER
  MACHINE_LEARNING_ENGINEER
  AI_ENGINEER
  CLOUD_ARCHITECT
  SITE_RELIABILITY_ENGINEER
  EMBEDDED_SYSTEMS_ENGINEER
  FIRMWARE_ENGINEER
  GAME_DEVELOPER
  SECURITY_ENGINEER

  DATA_SCIENTIST
  DATA_ANALYST
  BUSINESS_INTELLIGENCE_ANALYST
  DATA_ENGINEER
  RESEARCH_SCIENTIST
  ML_OPS_ENGINEER
  NLP_ENGINEER
  AI_RESEARCHER

  UX_DESIGNER
  UI_DESIGNER
  PRODUCT_DESIGNER
  GRAPHIC_DESIGNER
  INTERACTION_DESIGNER
  VISUAL_DESIGNER
  DESIGN_RESEARCHER

  PRODUCT_MANAGER
  PROJECT_MANAGER
  SCRUM_MASTER
  TECHNICAL_PROGRAM_MANAGER
  TECH_LEAD
  ENGINEERING_MANAGER
  AGILE_COACH

  QA_TESTER
  TEST_AUTOMATION_ENGINEER
  QUALITY_ASSURANCE_ENGINEER

  BUSINESS_ANALYST
  OPERATIONS_MANAGER
  CUSTOMER_SUCCESS_MANAGER
  CUSTOMER_SUPPORT_SPECIALIST
  SALES_ENGINEER
  ACCOUNT_MANAGER

  MARKETING_SPECIALIST
  GROWTH_HACKER
  CONTENT_STRATEGIST
  SEO_SPECIALIST
  SOCIAL_MEDIA_MANAGER
  DIGITAL_MARKETING_MANAGER

  SYSTEM_ADMINISTRATOR
  IT_SUPPORT
  NETWORK_ENGINEER
  HELP_DESK_TECHNICIAN
  DATABASE_ADMINISTRATOR
  SECURITY_ANALYST
  CYBERSECURITY_SPECIALIST

  TECHNICAL_WRITER
  CONTENT_WRITER
  UX_WRITER
  DOCUMENTATION_SPECIALIST

  RESEARCHER
  LECTURER
  ACADEMIC_COORDINATOR
  EDUCATION_TECHNOLOGIST

  BIOINFORMATICS_SCIENTIST
  COMPUTATIONAL_BIOLOGIST
  MEDICAL_DATA_ANALYST

  WAITER
  WAITRESS
  CHEF
  SOUS_CHEF
  LINE_COOK
  KITCHEN_ASSISTANT
  RESTAURANT_MANAGER
  BARISTA
  BARTENDER
  HOST
  HOSTESS
  DISHWASHER
  SOMMELIER
  PASTRY_CHEF
  FOOD_RUNNER
  CATERING_STAFF

  CTO
  CIO
  CHIEF_PRODUCT_OFFICER
  VP_OF_ENGINEERING
  FOUNDER
  CO_FOUNDER

  FREELANCE_DEVELOPER
  REMOTE_ENGINEER
  CONTRACTOR

  INTERN
  JUNIOR_DEVELOPER
  GRADUATE_SOFTWARE_ENGINEER

  TECH_ENTHUSIAST
  HACKER
  OPEN_SOURCE_CONTRIBUTOR
  MENTOR
  VOLUNTEER
  ENTREPRENEUR
  OTHER
  USER
  ADMIN
}


model User {
  id                     String         @id @default(cuid()) @map("_id")
  name                   String
  email                  String         @unique
  emailVerified          DateTime?
  image                  String?
  password               String?
  role                   UserRole       @default(USER)
  
  friendRequestsSent     FriendRequest[] @relation("Sender")
  friendRequestsReceived FriendRequest[] @relation("Receiver")
  accounts               Account[]

  isTwoFactorEnabled Boolean @default(false)
  twoFactorConfirmation TwoFactorConfirmation?

  friendshipsAsUserA     Friendship[]   @relation("Friendship_userA")
  friendshipsAsUserB     Friendship[]   @relation("Friendship_userB")
  
  // Add these fields to complete the Message relation
  messagesSent           Message[]      @relation("MessagesSent")
  messagesReceived       Message[]      @relation("MessagesReceived")
  skills                 String[]       // No need for @db.Array here
  rejectedRequestsSent     RejectedRequest[] @relation("rejectedBySender")
  rejectedRequestsReceived RejectedRequest[] @relation("rejectedByReceiver")

}

model Friendship {
  id       String @id @default(cuid()) @map("_id")
  userAId  String
  userBId  String
  userA    User   @relation("Friendship_userA", fields: [userAId], references: [id])
  userB    User   @relation("Friendship_userB", fields: [userBId], references: [id])
  createdAt DateTime @default(now())

  // Ensure uniqueness to prevent duplicate friendships
  @@unique([userAId, userBId])

}

model FriendRequest {
  id          String   @id @default(cuid()) @map("_id")
  senderId    String
  receiverId  String
  status      String   // "pending", "accepted", or "rejected"
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sender      User     @relation("Sender", fields: [senderId], references: [id])
  receiver    User     @relation("Receiver", fields: [receiverId], references: [id])
}



model RejectedRequest {
  id         String   @id @default(cuid()) @map("_id")
  senderId   String
  receiverId String
  rejectedAt DateTime @default(now())
  
  sender     User     @relation("rejectedBySender", fields: [senderId], references: [id])
  receiver   User     @relation("rejectedByReceiver", fields: [receiverId], references: [id])
  
  @@unique([senderId, receiverId])
}

model Message {
  id          String   @id @default(cuid()) @map("_id")
  senderId    String
  receiverId  String
  text        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  status      String   @default("sending") // Add this field for message status

  sender      User     @relation("MessagesSent", fields: [senderId], references: [id])
  receiver    User     @relation("MessagesReceived", fields: [receiverId], references: [id])
}

model Account {
  id                 String   @id @default(cuid()) @map("_id")
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @map("_id") @default(cuid())  // Map 'id' to MongoDB's '_id'
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken{
  id String @id @map("_id") @default(cuid())
  email String
  token String @unique
  expires DateTime

  @@unique ([email,token])

}

model TwoFactorToken{
  id String @id @map("_id") @default(cuid())
  email String
  token String @unique
  expires DateTime

  @@unique ([email,token])

}

model TwoFactorConfirmation {
  id     String @id @map("_id") @default(cuid())
  userId String                     // Add this line
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}
